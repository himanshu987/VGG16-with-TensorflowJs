"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatMulPackedProgram = (function () {
    function MatMulPackedProgram(aShape, bShape, outputShape, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.variableNames = ['matrixA', 'matrixB'];
        this.outputShape = outputShape;
        var sharedDim = transposeA ? aShape[0] : aShape[1];
        var sharedDimensionPacked = Math.ceil(sharedDim / 2);
        var aSample = transposeA ? 'resultUV.t, center' : 'center, resultUV.t';
        var bSample = transposeB ? 'center, resultUV.s' : 'resultUV.s, center';
        var aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];
        var bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];
        this.userCode = "\n      const float sharedDimension = " + sharedDimensionPacked + ".0;\n\n      vec4 dot2x2ARowBCol() {\n        vec4 result = vec4(0);\n        for (int ii = 0; ii < " + sharedDimensionPacked + "; ii++) {\n          float i = float(ii);\n          float center = (i + 0.5) / sharedDimension;\n          vec4 a = texture2D(matrixA, vec2(" + aSample + "));\n          vec4 b = texture2D(matrixB, vec2(" + bSample + "));\n\n          result += (" + aSwizzle[0] + " * " + bSwizzle[0] + ") + (" + aSwizzle[1] + " * " + bSwizzle[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        gl_FragColor = dot2x2ARowBCol();\n      }\n    ";
    }
    return MatMulPackedProgram;
}());
exports.MatMulPackedProgram = MatMulPackedProgram;
//# sourceMappingURL=mulmat_packed_gpu.js.map